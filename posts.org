#+hugo_base_dir: ./
#+STARTUP: nolatexpreview
* About
:PROPERTIES:
:export_hugo_section: ./
:END:

** DONE (Yet Another) Intro
CLOSED: [2022-11-14 Mon 23:58]
:PROPERTIES:
:EXPORT_FILE_NAME: about
:END:

[[/images/about-photo.png]]

Hi, I'm Woosang, currently a CS undergraduate at a college in Upstate New York. My interest lies on creating resilient backend services (especially for Go), building foolproof measures for development procedures (e.g. CI pipelines), and tweaking Emacs configs.

On my spare time, I like to [[https://youtu.be/qyQLNk6QoJk][make music]], hike mountains and chill with my cats.

* Posts
:PROPERTIES:
:export_hugo_section: posts
:END:

** DONE First Post! :org:hugo:@scribbles:
CLOSED: [2022-11-12 Sat 18:56]
:PROPERTIES:
:EXPORT_FILE_NAME: first-post
:END:

I used to maintain a rather clunky blog, which was a mixture of =Gulp 4= and =Sass=, but finally gathered my willpower to move on to a lightweight platform.
+ Due to all the heavy assets, the blog template itself (devoid of any content) took up about 10MB. Some parts were brought from a obscure source, so I really did not have a clear understanding of what was going on under the hood.
+ Adding a new page was a pain with the absence of an universial template; dealing with all the HTML tags and what not. I wanted a platform where I could easily jot down stuff, not a polished space without any real content.
That was when I ran into [[https://gohugo.io][Hugo]] paired with [[https://ox-hugo.scripter.co/][ox-Hugo]], a backend that exports Org-mode docs in Emacs to Hugo-compatible MD files. And after my first take, I can't help but appreciate the convenience!
+ The whole [[https://github.com/paul-kang-1/pr-website][Blog repo]] stays under 1KB, and I can leverage tools like =Org-capture= to easily create new posts.
+ With the below command and some use of [[https://ox-hugo.scripter.co/doc/auto-export-on-saving/][autosave setup]], you can introduce hot loading to the local development.
  #+begin_src sh
  hugo server --buildDrafts --navigateToChanged
  #+end_src
Anyway, it feels like I've finally found a nice and cozy setup. Let's see where this leads to!

** TODO Dependency Injection in Go Microservices :dev:go:@TIL:
:PROPERTIES:
:EXPORT_FILE_NAME: dependency-injection
:END:

*** Breaking the Code Coupling
Prior to adopting the Dependency Injection pattern, "unit testing" the codebase was virtually impossible, mainly due to its external dependencies (e.g. Firebase Cloud Messaging client), which had to be initialized solely to test a small snippet of newly written code.

*** Enforcing The Repository Pattern
Although the previous codebase vaguely followed the idea of the Repository Pattern, it failed to

#+begin_src go
type (
	HallService interface {
		CreateHallWithTx(
			ctx context.Context, sqlTx boil.ContextExecutor, option repositories.HallOption
		) (*models.Hall, error)
		GetHallWithTxOf(
			ctx context.Context, sqlTx boil.ContextExecutor, userID int
		) (*models.Hall, error)
	}

	HallServiceInstance struct {
		hallRepository repositories.HallRepository
	}
)

func NewHallService(h repositories.HallRepository) *HallServiceInstance {
	return &HallServiceInstance{h}
}
#+end_src

*** Facilitating DI with Wire
Although DI improves code readability and eases up the testing procedure, it doesn't exactly scale well as the complexity of the dependency graph increases. Wire provides a number of key advantages compared to manual DI, or other tools like Uber's [[https://github.com/uber-go/dig][dig]]:
+ **Compile-time injection**: It's always to find any discrepancies in the dependency graph prior to running the actual application.
+ **Enhanced readability**: In many cases, there will be several /initialization groups/

*** References
+ [[https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design#the-repository-pattern][The Repository Pattern]]
+ [[https://github.com/google/wire/blob/main/docs/guide.md][Google Wire Guide]]

** TODO Testing Repository Pattern Softwares in Go (1/2) :dev:go:testing:@TIL:
:PROPERTIES:
:EXPORT_FILE_NAME: repository-pattern-testing-1
:END:

It is fairly easy to perform unit tests in the context of a Repository pattern-based software: simply create mock dependencies with predefined behavior, and initialize the target service with them to check the code logic in a vacuum.

** TODO Testing Repository Pattern Softwares in Go (2/2) :dev:go:testing:@TIL:
:PROPERTIES:
:EXPORT_FILE_NAME: repository-pattern-testing-2
:END:

While the last post mostly focused on unit testing, which let us test code that we exclusively wrote in a vacuum, one other venue of testing that may be worth exploring would be **integration testing**.

** DONE CI Pipeline for Monorepo-based Microservices
CLOSED: [2023-06-11 Sun 21:01]
:PROPERTIES:
:EXPORT_FILE_NAME: ci-pipeline-for-monorepo-based-microservices
:END:

WIP Content

** DONE Understanding Different Consistency Guarantees :systems:@TIL:
CLOSED: [2023-04-24 Mon 01:14]
:PROPERTIES:
:EXPORT_FILE_NAME: linearizability-and-varying-degrees-of-consistencies
:END:

 When it comes to implementing distributed systems, there are a whole variety of consistency models to choose from. Going through papers on system implementations of varying degrees of consistency guarantees (e.g.[[http://www.cs.cornell.edu/courses/cs5414/2017fa/papers/Spanner.pdf][Spanner]] or [[http://www.cs.utexas.edu/~lorenzo/corsi/cs380d/papers/p172-terry.pdf][Bayou]]), I found myself mixing up strictly different terms and models. To prevent further confusion, I thought it would be a good idea to cover some key terminologies here.

*** What /is/ Consistency?
There are myriads of different consistency guarantees, but what /is/ consistency in the context of distributed systems in the first place? Different definitions may exist, but I found the following the clearest: **consistency** is a test on the execution of operations[fn:1] (WLOG, let's limit the type of operations to ~read()~ and ~write(v)~ for the sake of simplicity): if the test for a consistency condition $C$ passes on execution $e$, we say $e$ is $C$-consistent.

We can also define hierarchies between different consistency semantics: $C_s$ is /stronger/ than $C_w$ if and only if the set of executions accepted by $C_s$ is a subset of the set of executions accepted by $C_w$. ($E_{C_s}\subset E_{C_w}$) If neither of them is stronger, than the two are incomparable.

*** Causal Consistency
Using Lamport's /happened-before/ relation, we can define a consistency semantic. As the [[https://www.cs.cornell.edu/lorenzo/papers/cac-tr.pdf][CAC]] paper states, an execution is /causally consistent/ if $\exists$ a DAG $G$, a happens-before graph defined by the /precedes/ partial ordering ($\succ_G$), satisfies the following check:

+ Serial ordering at each node: If $v$ and $v^{\prime}$ are vertices corresponding to operations by the same node, $v.startTime < v^{\prime}.startTime \Leftrightarrow v\prec_G v^{\prime}$.
+ Read returns the latest preceding concurrent writes. Note that this doesn't place any restrictions  on the ordering of each of the concurrent writes.

The second point essentially /separates consistency from conflict resolution/, as in the responsibility of resolving order between the concurrent writes is passed to the individual nodes. So there is **no guarantee of a total ordering** in an execution that is causally consistent; as long as the partial ordering defined by a happened-before relation is satisfied, different nodes may observe different permutations of a valid execution.

**** Real-time-causal Consistency (RTC)
We could also add a real-time requirement to the consistency test regarding the happened-before graph above. An execution $e$ is /RTC consistent/ if the HB graph satisfies this additional property:
+ $\forall u, v: u.endTime < v.startTime \Rightarrow v \nprec_G u$

*** Sequential Consistency (Lamport)
Unlike causal consistency, sequential consistency constrains the execution to be in some /total order/, and the resulting execution should be consistent with the order of operations on each individual nodes.

*** Linearizability

*** External Consistency (Gifford)

*** Serializability

*** Footnotes
[fn:1] Adopted from [[https://www.cs.cornell.edu/lorenzo/papers/cac-tr.pdf][Consistency, Availability and Convergence (Marajan et al.)]]

*** Further Readings
+ [[https://jepsen.io/consistency][Consistency Models (Jepsen)]]
+ [[https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwi2mqernbX-AhXQMlkFHSzDAQoQFnoECAwQAQ&url=https%3A%2F%2Fcs.brown.edu%2F~mph%2FHerlihyW90%2Fp463-herlihy.pdf&usg=AOvVaw2I8TvobQuAizpu3MojvSZO][Linearizability: A Correctness Condition for Concurrent Objects (Herilhy)]]
+ [[https://www.cs.cornell.edu/lorenzo/papers/cac-tr.pdf][Consistency, Availability and Convergence (Marajan et al.)]]

** DONE C++ Setup for Neovim :dev:vim:@TIL:
CLOSED: [2023-06-12 Mon 01:43]
:PROPERTIES:
:EXPORT_FILE_NAME: c-plus-plus-setup-for-neovim
:END:

There are a plethora of different ways to setup a C++ development environment in Neovim. Here's one possible way that I landed on after a number of (unsuccessful) attempts on Linux, integrated as a part of my [[https://github.com/paul-kang-1/dotfiles][dotfiles]].

*** Mason and Lsp-Zero (optional)
[[https://github.com/williamboman/mason.nvim][mason.nvim]] is a package manager for Neovim that enables the installation of different utilities (mainly LSP/DAP servers and linter/formatters).

[[https://github.com/VonHeikemen/lsp-zero.nvim][lsp-zero.nvim]] provides a sweet spot between an out-of-the-box experience and configurability for setting up language-specific functionalities. The barebones plugin configuration with support for Mason for [[https://github.com/wbthomason/packer.nvim][packer.nvim]]
is as below ([[https://github.com/VonHeikemen/lsp-zero.nvim#quickstart-for-the-impatient][source]]):

#+begin_src lua
use {
    'VonHeikemen/lsp-zero.nvim',
    branch = 'v2.x',
    requires = {
        -- LSP Support
        { 'neovim/nvim-lspconfig' }, -- Required
        {
            -- Optional
            'williamboman/mason.nvim',
            run = function()
                pcall(vim.cmd, 'MasonUpdate')
            end,
        },
        { 'williamboman/mason-lspconfig.nvim' }, -- Optional

        -- Autocompletion
        { 'hrsh7th/nvim-cmp' }, -- Required
        { 'hrsh7th/cmp-nvim-lsp' }, -- Required
        { 'hrsh7th/cmp-buffer' }, -- Optional
        { 'hrsh7th/cmp-path' }, -- Optional
        { 'saadparwaiz1/cmp_luasnip' }, -- Optional
        { 'hrsh7th/cmp-nvim-lua' }, -- Optional

        -- Snippets
        { 'L3MON4D3/LuaSnip' },    -- Required
        { 'rafamadriz/friendly-snippets' }, -- Optional
    }
}
#+end_src


*** Setting up ~clangd~ and ~clang-format~
After the prerequisites are installed, there may not be any immediate changes. That is because you'll have to provide the Clang compiler, which ~clangd~ is based on, with explicit guidance on compilation. There are different ways to supply the compilation flags to ~clangd~, but for a simple sandbox, a =.clangd= file (or a =compile_flags.txt=) may suffice. A Cmake-generated =compile_commands.json= compilation database file could also do the job for larger projects. The flags are apparently version/platform specific, so double check the system settings!

#+begin_src shell
CompileFlags:
  Add: [-std=c++20, -Wall, -I/usr/include/c++/11, -I/usr/include/x86_64-linux-gnu/c++/11]
#+end_src

Now that the errors are gone, it's time to fine tune the formatter, ~clang-format~. This can simply be done by adding a =.clang-format= file with different [[https://clang.llvm.org/docs/ClangFormatStyleOptions.html][options]] at the root directory of the project. And that's it!

*** Further Troubleshooting
One error that took me a particularly long time figuring out the root cause was the error message =bits/c++config.h file not found= that occured in headers. I tried including the directories that apparently included the lacking file, but the issue persisted. To dig deeper, I tried compiling a small test file with the following flags with ~clang++~.

#+begin_src shell
$ clang++ --std=c++2a -Wall --verbose main.cpp -o test \
    -I/usr/include/c++/11 \
    -I/usr/include/c++/x86_64-linux-gnu/11

clang version 17.0.0 (https://github.com/llvm/llvm-project.git f5a8802fa6021ab05dd126ea64f594f84c6c90d9)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /home/woosang.kang/.local/share/llvm-project/build/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11
Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/12
Selected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/12
#+end_src

So it turned out to be that I've installed an older version of ~libstdc++~ that ~clang~ wasn't using! After installing =libstdc++-12-dev= along with =g++-12-multilib= and =gcc-12-multilib=, all the features were working seamlessly without any additional configuration files.
