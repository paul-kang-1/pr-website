#+hugo_base_dir: ./
* About
:PROPERTIES:
:export_hugo_section: ./
:END:

** DONE (Yet Another) Intro
CLOSED: [2022-11-14 Mon 23:58]
:PROPERTIES:
:EXPORT_FILE_NAME: about
:END:

[[/images/about-photo.png]]

Hi, I'm Woosang, currently a CS undergraduate at a college in Upstate New York. My interest lies on creating resilient backend services (especially for Go), building foolproof measures for development procedures (e.g. CI pipelines), and tweaking Emacs configs.

On my spare time, I like to [[https://youtu.be/qyQLNk6QoJk][make music]], hike mountains and chill with my cats.

* Posts
:PROPERTIES:
:export_hugo_section: posts
:END:

** DONE First Post! :org:hugo:@scribbles:
CLOSED: [2022-11-12 Sat 18:56]
:PROPERTIES:
:EXPORT_FILE_NAME: first-post
:END:

I used to maintain a rather clunky blog, which was a mixture of =Gulp 4= and =Sass=, but finally gathered my willpower to move on to a lightweight platform.
+ Due to all the heavy assets, the blog template itself (devoid of any content) took up about 10MB. Some parts were brought from a obscure source, so I really did not have a clear understanding of what was going on under the hood.
+ Adding a new page was a pain with the absence of an universial template; dealing with all the HTML tags and what not. I wanted a platform where I could easily jot down stuff, not a polished space without any real content.
That was when I ran into [[https://gohugo.io][Hugo]] paired with [[https://ox-hugo.scripter.co/][ox-Hugo]], a backend that exports Org-mode docs in Emacs to Hugo-compatible MD files. And after my first take, I can't help but appreciate the convenience!
+ The whole [[https://github.com/paul-kang-1/pr-website][Blog repo]] stays under 1KB, and I can leverage tools like =Org-capture= to easily create new posts.
+ With the below command and some use of [[https://ox-hugo.scripter.co/doc/auto-export-on-saving/][autosave setup]], you can introduce hot loading to the local development.
  #+begin_src sh
  hugo server --buildDrafts --navigateToChanged
  #+end_src
Anyway, it feels like I've finally found a nice and cozy setup. Let's see where this leads to!

** DONE Dependency Injection in Go Microservices :dev:go:@TIL:
CLOSED: [2023-01-02 Mon 12:31]
:PROPERTIES:
:EXPORT_FILE_NAME: dependency-injection
:END:

*** Breaking the Code Coupling
Prior to adopting the Dependency Injection pattern, "unit testing" the codebase was virtually impossible, mainly due to its external dependencies (e.g. Firebase Cloud Messaging client), which had to be initialized solely to test a small snippet of newly written code.

*** Enforcing The Repository Pattern
Although the previous codebase vaguely followed the idea of the Repository Pattern, it failed to

#+begin_src go
type (
	HallService interface {
		CreateHallWithTx(
			ctx context.Context, sqlTx boil.ContextExecutor, option repositories.HallOption
		) (*models.Hall, error)
		GetHallWithTxOf(
			ctx context.Context, sqlTx boil.ContextExecutor, userID int
		) (*models.Hall, error)
	}

	HallServiceInstance struct {
		hallRepository repositories.HallRepository
	}
)

func NewHallService(h repositories.HallRepository) *HallServiceInstance {
	return &HallServiceInstance{h}
}
#+end_src

*** Facilitating DI with Wire
Although DI improves code readability and eases up the testing procedure, it doesn't exactly scale well as the complexity of the dependency graph increases. Wire provides a number of key advantages compared to manual DI, or other tools like Uber's [[https://github.com/uber-go/dig][dig]]:
+ **Compile-time injection**: It's always to find any discrepancies in the dependency graph prior to running the actual application.
+ **Enhanced readability**: In many cases, there will be several /initialization groups/

*** References
+ [[https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design#the-repository-pattern][The Repository Pattern]]
+ [[https://github.com/google/wire/blob/main/docs/guide.md][Google Wire Guide]]

** TODO Testing Repository Pattern Softwares in Go (1/2) :dev:go:testing:@TIL:
:PROPERTIES:
:EXPORT_FILE_NAME: repository-pattern-testing-1
:END:

It is fairly easy to perform unit tests in the context of a Repository pattern-based software: simply create mock dependencies with predefined behavior, and initialize the target service with them to check the code logic in a vacuum.

** TODO Testing Repository Pattern Softwares in Go (2/2) :dev:go:testing:@TIL:
:PROPERTIES:
:EXPORT_FILE_NAME: repository-pattern-testing-2
:END:

While the last post mostly focused on unit testing, which let us test code that we exclusively wrote in a vacuum, one other venue of testing that may be worth exploring would be **integration testing**.

** TODO CI Pipeline for Monorepo-based Microservices
:PROPERTIES:
:EXPORT_FILE_NAME: ci-pipeline-for-monorepo-based-microservices
:END:

WIP Content

** DONE Understanding Different Consistency Guarantees :systems:@TIL:
CLOSED: [2023-04-24 Mon 01:14]
:PROPERTIES:
:EXPORT_FILE_NAME: linearizability-and-varying-degrees-of-consistencies
:END:

On implementing a distributed system, there are a whole variety of consistency models to choose from. Going through papers on system implementations of varying degrees of consistency guarantees (e.g.[[http://www.cs.cornell.edu/courses/cs5414/2017fa/papers/Spanner.pdf][Spanner]] or [[http://www.cs.utexas.edu/~lorenzo/corsi/cs380d/papers/p172-terry.pdf][Bayou]]), I found myself using strictly different terms and models interchangeably. To prevent further confusion, I thought it would be a good idea to cover some key terminologies here.

*** What /is/ Consistency?
In a distributed systems perspective, **consistency** is a test on the execution of operations[fn:1] (here, let's limit the type of operations to ~read()~ and ~write(v)~ for the sake of simplicity): if the test for a consistency condition $C$ passes on execution $e$, we say $e$ is $C$-consistent.

We can also define hierarchies between different consistency semantics: $C_s$ is /stronger/ than $C_w$ iff the set of executions accepted by $C_s$ is a subset of the set of executions accepted by $C_w$. ($E_{C_s}\subset E_{C_w}$) If neither of them is stronger, than the two are incomparable.

*** Causal Consistency
Using Lamport's /happened-before/ relation, we can define a consistency semantic. As the [[https://www.cs.cornell.edu/lorenzo/papers/cac-tr.pdf][CAC]] paper states, an execution is /causally consistent/ if $\exists$ a DAG $G$, a happens-before graph defined by the /precedes/ partial ordering ($\succ_G$), satisfies the following check:

+ Serial ordering at each node: If $v$ and $v^{\prime}$ are vertices corresponding to operations by the same node, $v.startTime < v^{\prime}.startTime \Leftrightarrow v\prec_G v^{\prime}$.
+ Read returns the latest preceding concurrent writes. Note that this doesn't place any restrictions  on the ordering of each of the concurrent writes.

The second point essentially /separates consistency from conflict resolution/, as in the responsibility of resolving order between the concurrent writes is passed to the individual nodes. So there is **no guarantee of a total ordering** in an execution that is causally consistent; as long as the partial ordering defined by a happened-before relation is satisfied, different nodes may observe different permutations of a valid execution.

**** Real-time-causal Consistency (RTC)
We could also add a real-time element to the consistency test regarding the happened-before graph above. An execution $e$ is /RTC consistent/ if the HB graph satisfies this additional property:
+ $\forall u, v: u.endTime < v.startTime \Rightarrow v \nprec_G u$ ()

*** Sequential Consistency (Lamport)
Unlike causal consistency, sequential consistency constrains the execution to be in some /total order/, and the resulting execution should be consistent with the order of operations on each individual nodes.

*** Linearizability

*** External Consistency (Gifford)

*** Serializability

*** Footnotes
[fn:1] Adopted from [[https://www.cs.cornell.edu/lorenzo/papers/cac-tr.pdf][Consistency, Availability and Convergence (Marajan et al.)]]

*** Further Readings
+ [[https://jepsen.io/consistency][Consistency Models (Jepsen)]]
+ [[https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwi2mqernbX-AhXQMlkFHSzDAQoQFnoECAwQAQ&url=https%3A%2F%2Fcs.brown.edu%2F~mph%2FHerlihyW90%2Fp463-herlihy.pdf&usg=AOvVaw2I8TvobQuAizpu3MojvSZO][Linearizability: A Correctness Condition for Concurrent Objects (Herilhy)]]
+ [[https://www.cs.cornell.edu/lorenzo/papers/cac-tr.pdf][Consistency, Availability and Convergence (Marajan et al.)]]

** TODO Spanner :system:@Papers
:PROPERTIES:
:EXPORT_FILE_NAME: spanner
:END:

TODO

** TODO Dynamo :system:@Papers
:PROPERTIES:
:EXPORT_FILE_NAME: dynamo
:END:

TODO

** TODO Bayou :system:@Papers
:PROPERTIES:
:EXPORT_FILE_NAME: bayou
:END:

TODO
